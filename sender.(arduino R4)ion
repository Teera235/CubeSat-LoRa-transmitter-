#include <SPI.h>

// SX1276/78 Register Map - ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ó‡∏µ‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô
#define REG_FIFO                 0x00
#define REG_OP_MODE             0x01
#define REG_FRF_MSB             0x06
#define REG_FRF_MID             0x07
#define REG_FRF_LSB             0x08
#define REG_PA_CONFIG           0x09
#define REG_FIFO_ADDR_PTR       0x0D
#define REG_FIFO_TX_BASE_ADDR   0x0E
#define REG_IRQ_FLAGS           0x12
#define REG_MODEM_CONFIG_1      0x1D
#define REG_MODEM_CONFIG_2      0x1E
#define REG_PREAMBLE_LSB        0x21
#define REG_PAYLOAD_LENGTH      0x22
#define REG_MODEM_CONFIG_3      0x26
#define REG_PA_DAC              0x4D

// Operation Modes
#define MODE_LONG_RANGE_MODE    0x80
#define MODE_SLEEP              0x00
#define MODE_STDBY              0x01
#define MODE_TX                 0x03

// Pin definitions
#define SS_PIN    10
#define RST_PIN   9
#define DIO0_PIN  2

// ‚ö° ULTRA PERFORMANCE SETTINGS
#define PACKET_SIZE 8           // ‡πÄ‡∏•‡πá‡∏Å‡∏™‡∏∏‡∏î = ‡πÄ‡∏£‡πá‡∏ß‡∏™‡∏∏‡∏î
#define SEND_INTERVAL_US 20000  // 20ms = 50 pps (packets per second)
#define BURST_COUNT 5           // ‡∏™‡πà‡∏á‡∏ä‡∏∏‡∏î‡∏•‡∏∞ 5 packets

// Global variables - optimized
uint16_t packetCount = 0;
uint8_t txBuffer[PACKET_SIZE];
unsigned long lastSendTime = 0;
uint8_t burstIndex = 0;

// Pre-calculated constants
const uint8_t FIFO_TX_BASE = 0x80;
const uint8_t TX_DONE_FLAG = 0x08;

// SPI Settings for modern Arduino Core
SPISettings spiSettings(8000000, MSBFIRST, SPI_MODE0); // 8MHz SPI

void setup() {
  Serial.begin(500000); // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß Serial
  while (!Serial);
  
  Serial.println("üöÄ ULTRA REALTIME LoRa - MAX SPEED MODE");
  
  // Initialize pins - fast mode
  pinMode(SS_PIN, OUTPUT);
  pinMode(RST_PIN, OUTPUT);
  pinMode(DIO0_PIN, INPUT);
  digitalWrite(SS_PIN, HIGH);
  
  // ‚ö° MAXIMUM SPEED SPI - Modern Arduino Core
  SPI.begin();
  // SPI settings ‡∏à‡∏∞‡πÉ‡∏ä‡πâ‡πÉ‡∏ô beginTransaction ‡πÅ‡∏ó‡∏ô
  
  // Reset & init
  resetModule();
  initLoRaUltraFast();
  
  Serial.println("‚úÖ ULTRA FAST MODE READY - 50+ PPS!");
  Serial.println("üìä SF7, BW500kHz, 8-byte packets, 20ms burst");
}

void loop() {
  unsigned long now = micros(); // ‡πÉ‡∏ä‡πâ micros ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥
  
  if (now - lastSendTime >= SEND_INTERVAL_US) {
    lastSendTime = now;
    
    // üöÄ BURST MODE - ‡∏™‡πà‡∏á‡∏´‡∏•‡∏≤‡∏¢ packets ‡∏ï‡∏¥‡∏î‡∏Å‡∏±‡∏ô
    sendBurstPackets();
    
    // Status every 1000 packets
    if (packetCount % 1000 == 0) {
      Serial.print("‚ö° TURBO #");
      Serial.print(packetCount);
      Serial.println(" | 50+pps");
    }
  }
}

void resetModule() {
  digitalWrite(RST_PIN, LOW);
  delay(5);  // ‡∏•‡∏î‡πÄ‡∏ß‡∏•‡∏≤ reset
  digitalWrite(RST_PIN, HIGH);
  delay(5);
}

// ‚ö° FAST REGISTER ACCESS - Compatible with all Arduino cores
void writeRegisterFast(uint8_t address, uint8_t value) {
  SPI.beginTransaction(spiSettings);
  digitalWrite(SS_PIN, LOW);
  SPI.transfer(address | 0x80); // Write mode
  SPI.transfer(value);
  digitalWrite(SS_PIN, HIGH);
  SPI.endTransaction();
}

uint8_t readRegisterFast(uint8_t address) {
  SPI.beginTransaction(spiSettings);
  digitalWrite(SS_PIN, LOW);
  SPI.transfer(address & 0x7F); // Read mode
  uint8_t value = SPI.transfer(0x00);
  digitalWrite(SS_PIN, HIGH);
  SPI.endTransaction();
  return value;
}

void initLoRaUltraFast() {
  // Enter sleep mode
  writeRegisterFast(REG_OP_MODE, MODE_SLEEP | MODE_LONG_RANGE_MODE);
  delay(10);
  
  // 433MHz frequency - pre-calculated
  writeRegisterFast(REG_FRF_MSB, 0x6C);
  writeRegisterFast(REG_FRF_MID, 0x80);
  writeRegisterFast(REG_FRF_LSB, 0x00);
  
  // ‚ö° MAXIMUM POWER & SPEED SETTINGS
  writeRegisterFast(REG_PA_CONFIG, 0xFF);  // Max power +20dBm
  writeRegisterFast(REG_PA_DAC, 0x87);     // High power mode
  
  // üöÄ HIGH SPEED SETTINGS (‡∏õ‡∏£‡∏±‡∏ö‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ‡∏à‡∏£‡∏¥‡∏á)
  writeRegisterFast(REG_MODEM_CONFIG_1, 0x72); // BW=500kHz, CR=4/5, Implicit Header OFF
  writeRegisterFast(REG_MODEM_CONFIG_2, 0x74); // SF=7 (‡πÄ‡∏£‡πá‡∏ß‡πÅ‡∏•‡∏∞‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ), CRC ON
  writeRegisterFast(REG_MODEM_CONFIG_3, 0x0C); // LowDataRate OFF, AGC ON
  
  // Minimum preamble = maximum speed
  writeRegisterFast(REG_PREAMBLE_LSB, 0x06); // 6 symbols only
  
  // Set TX base address
  writeRegisterFast(REG_FIFO_TX_BASE_ADDR, FIFO_TX_BASE);
  
  // Enter standby
  writeRegisterFast(REG_OP_MODE, MODE_STDBY | MODE_LONG_RANGE_MODE);
  delay(10);
  
  Serial.println("üìä SETTINGS: 433MHz, SF7, BW500kHz, CR4/5, +20dBm");
}

// ‚ö° ULTRA COMPACT PACKET - ‡πÄ‡∏•‡πá‡∏Å‡∏™‡∏∏‡∏î = ‡πÄ‡∏£‡πá‡∏ß‡∏™‡∏∏‡∏î
void createUltraPacket() {
  txBuffer[0] = 0xAA;                           // Header
  txBuffer[1] = (packetCount >> 8) & 0xFF;      // ID high
  txBuffer[2] = packetCount & 0xFF;             // ID low
  
  // Real-time sensor data
  uint16_t sensor = analogRead(A0);             // ‡∏≠‡πà‡∏≤‡∏ô‡πÄ‡∏ã‡∏ô‡πÄ‡∏ã‡∏≠‡∏£‡πå‡∏à‡∏£‡∏¥‡∏á
  txBuffer[3] = (sensor >> 8) & 0xFF;
  txBuffer[4] = sensor & 0xFF;
  
  // Timestamp (3 bytes - ‡∏õ‡∏£‡∏∞‡∏´‡∏¢‡∏±‡∏î‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà)
  uint32_t ts = millis();
  txBuffer[5] = (ts >> 16) & 0xFF;
  txBuffer[6] = (ts >> 8) & 0xFF;
  txBuffer[7] = ts & 0xFF;
}

// üöÄ ULTRA FAST TRANSMISSION - Modern Arduino Compatible
void sendUltraFastPacket() {
  // Set FIFO pointer
  writeRegisterFast(REG_FIFO_ADDR_PTR, FIFO_TX_BASE);
  writeRegisterFast(REG_PAYLOAD_LENGTH, PACKET_SIZE);
  
  // ‚ö° BURST WRITE TO FIFO - High Speed Method
  SPI.beginTransaction(spiSettings);
  digitalWrite(SS_PIN, LOW);
  SPI.transfer(REG_FIFO | 0x80); // Write to FIFO register
  
  // Send all bytes in burst
  for (uint8_t i = 0; i < PACKET_SIZE; i++) {
    SPI.transfer(txBuffer[i]);
  }
  
  digitalWrite(SS_PIN, HIGH);
  SPI.endTransaction();
  
  // Start transmission
  writeRegisterFast(REG_OP_MODE, MODE_TX | MODE_LONG_RANGE_MODE);
  
  // ‚ö° OPTIMIZED POLLING - wait for TX complete
  while ((readRegisterFast(REG_IRQ_FLAGS) & TX_DONE_FLAG) == 0) {
    // Busy wait - fastest method
    delayMicroseconds(10);
  }
  
  // Clear flags & back to standby
  writeRegisterFast(REG_IRQ_FLAGS, 0xFF);
  writeRegisterFast(REG_OP_MODE, MODE_STDBY | MODE_LONG_RANGE_MODE);
}

// üöÄ BURST MODE - ‡∏™‡πà‡∏á‡∏´‡∏•‡∏≤‡∏¢ packets ‡∏ï‡∏¥‡∏î‡∏Å‡∏±‡∏ô
void sendBurstPackets() {
  for (uint8_t i = 0; i < BURST_COUNT; i++) {
    createUltraPacket();
    sendUltraFastPacket();
    packetCount++;
    
    // Minimum gap between packets
    delayMicroseconds(2000); // 2ms gap
  }
}

// üî• TURBO MODE - ‡∏™‡πà‡∏á‡πÑ‡∏°‡πà‡∏´‡∏¢‡∏∏‡∏î (‡πÉ‡∏ä‡πâ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏™‡∏∏‡∏î‡πÜ)
void turboMode() {
  Serial.println("üî• ENTERING TURBO MODE - CONTINUOUS TX!");
  
  unsigned long startTime = millis();
  uint16_t turboCount = 0;
  
  // ‡∏™‡πà‡∏á‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏ß‡∏•‡∏≤ 10 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
  while (millis() - startTime < 10000) {
    createUltraPacket();
    sendUltraFastPacket();
    packetCount++;
    turboCount++;
    
    delayMicroseconds(1000); // 1ms gap
  }
  
  Serial.print("üî• TURBO COMPLETE! Sent ");
  Serial.print(turboCount);
  Serial.print(" packets in 10s = ");
  Serial.print(turboCount / 10);
  Serial.println(" pps average");
}

// üéØ MANUAL CONTROL FUNCTIONS
void sendSinglePacket() {
  createUltraPacket();
  sendUltraFastPacket();
  packetCount++;
  
  Serial.print("üì§ Manual packet #");
  Serial.print(packetCount);
  Serial.print(" | Sensor: ");
  Serial.println(analogRead(A0));
}

// ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏à‡∏≤‡∏Å Serial command
void serialEvent() {
  if (Serial.available()) {
    char cmd = Serial.read();
    switch (cmd) {
      case 't':
      case 'T':
        turboMode();
        break;
      case 's':
      case 'S':
        sendSinglePacket();
        break;
      case 'r':
      case 'R':
        Serial.println("üîÑ Resetting packet counter");
        packetCount = 0;
        break;
      case '?':
        Serial.println("üí° Commands:");
        Serial.println("  t = Turbo Mode (10s continuous)");
        Serial.println("  s = Send single packet");
        Serial.println("  r = Reset counter");
        Serial.println("  ? = Show help");
        break;
    }
  }
}

// üìä Performance monitoring
void printStats() {
  static unsigned long lastStatsTime = 0;
  static uint16_t lastPacketCount = 0;
  
  if (millis() - lastStatsTime >= 5000) { // ‡∏ó‡∏∏‡∏Å 5 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
    uint16_t packetsThisPeriod = packetCount - lastPacketCount;
    float pps = packetsThisPeriod / 5.0;
    
    Serial.print("üìà Performance: ");
    Serial.print(pps);
    Serial.print(" pps | Total: ");
    Serial.println(packetCount);
    
    lastStatsTime = millis();
    lastPacketCount = packetCount;
  }
}
